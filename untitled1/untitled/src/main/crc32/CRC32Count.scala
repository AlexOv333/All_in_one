package main.crc32

object CRC32Count {
  // Таблица значений CRC32, предварительно вычисленных для каждого возможного байта данных
  private val crc32Table: Array[Long] = Array.tabulate(256) { n =>
    // В цикле обрабатываем каждый возможный байт (от 0x00 до 0xFF)
    // и вычисляем соответствующее значение CRC32 для него.
    // Результаты сохраняются в таблице для последующего использования.
    (0 until 8).foldLeft(n.toLong) { (crc, _) =>
      // Создаем маску, чтобы проверить младший бит.
      // Если младший бит равен 1, маска будет -1, иначе - 0.
      val mask = -(crc & 1)
      // Используем стандартный полином для CRC32.
      // Обновляем значение CRC32 для текущего байта данных.
      (crc >>> 1) ^ (0xEDB88320L & mask)
    }
  }

  // Функция для вычисления CRC32 для массива байтов
  def calculateCRC32(bytes: Array[Byte]): Long = {
    // Начальное значение CRC32 (все биты установлены в 1)
    var crc: Long = 0xFFFFFFFFL
    // Обрабатываем каждый байт данных в массиве
    bytes.foreach { byte =>
      // Используем таблицу CRC32 для получения нового значения CRC32
      // на основе текущего байта и предыдущего значения CRC32.
      // Для этого применяем XOR между текущим значением CRC32 и текущим байтом данных,
      // затем применяем маску 0xFF, чтобы ограничить результат до 8 бит,
      // и используем этот результат как индекс для доступа к значению CRC32 в таблице.
      // Затем применяем операцию XOR между полученным значением и сдвигом CRC32 на 8 бит вправо.
      crc = crc32Table(((crc ^ byte) & 0xFF).toInt) ^ (crc >>> 8)
    }
    // Инвертируем биты CRC32 и возвращаем итоговое значение.
    crc ^ 0xFFFFFFFFL
  }
}
