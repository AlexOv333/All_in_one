# Alt Linux Cheatsheet

## Содержание
   - [Основы CMD](#основы-cmd)
   - [Перенаправление ввода и вывода](#перенаправление-ввода-и-вывода)
   - [Обработка текста](#обработка-текста)
   - [Файловые системы](#файловые-системы)
   - [Управление пользователями](#управление-пользователями)
   - [Управление конфигурациями](#управление-конфигурациями)
   - [Процессы](#процессы)
   - [Bash скрипты](#bash-скрипты)


### Основы CMD


1. Посмотреть текущее время и дату:
   ```sh
   date
2. Посмотреть календарь этого месяца:
   ```bash
   cal
3. Узнать текущую директорию:
   ```bash
   pwd
4. Перейти в домашнюю директорию:
   ```bash
   cd
5. Посмотреть содержимое рабочего каталога:
   ```bash
   ls
6. Просмотреть все файлы, включая скрытые:
   ```bash
   ls -a
7. Отобразить содержимое каталога в широком формате:
   ```bash
   ls -la
8. Перейти в директорию /etc:
   ```bash
   cd /etc
9. Посмотреть содержимое файла group:
   ```bash
   cat group
9. Посмотреть содержимое файлов passwd и group одной командой:
   ```bash
   cat passwd group
9. Создать несколько файлов с использованием шаблона:
   ```bash
   alias create_files='touch stud{0..N}.txt'
   create_files
9. Создать вложенные директории:
   ```bash
   mkdir -p dir1/dir2/dir3
9. Скопировать содержимое директории /etc/openssh в директорию dir2:
   ```bash
   cp -r /etc/openssh dir1/dir2
9. Создать файл alt, затем переименовать его в linux:
   ```bash
   touch alt
   mv alt linux
9. Удалить непустую директорию dir2:
   ```bash
   rm -r dir1/dir2
9. Создать директорию tmp_file и скопировать туда файлы с расширением .txt:
   ```bash
   mkdir tmp_file
   cp *.txt tmp_file
9. Удалить все файлы в директории tmp_file:
   ```bash
   rm tmp_file/*.txt
9. Просмотреть последние 15 команд:
   ```bash
   history | tail -n 15
### Перенаправление ввода и вывода
1. Перенаправить вывод команды ls -la в файл result1.txt:
    ```bash
    ls -la > result1.txt
2. Перенаправить ошибки команды ls -QJ в файл result2.txt:
    ```bash
    ls -QJ 2> result2.txt
3. Создать псевдоним команды для создания директории dir{ab}:
    ```bash
    alias make_dirs='mkdir dir{a,b}'
    make_dirs
4. Перенаправить вывод команды ps aux в программу less для удобного просмотра:
    ```bash
    ps aux | less
5. Использовать команду tee для одновременного вывода результата команды ls -la на экран и в файл:
    ```bash
    ls -la | tee result3.txt
6. Создать файл с именем $filename:
    ```bash
    touch \$filename
7. Подсчитать количество файлов и каталогов в текущей директории:
    ```bash
    ls -1 | wc -l
### Обработка текста
1. Найти строку, содержащую слово student в файле /etc/group:
    ```bash
    grep student /etc/group
2. Найти все строки со словом root в файлах /etc/passwd и /etc/group:
    ```bash
    grep root /etc/passwd /etc/group
3. Подсчитать количество строк со словом student в файле /etc/group:
    ```bash
    grep student /etc/group | wc -l
4. Подсчитать количество строк, в которых нет слова student:
    ```bash
    grep -v student /etc/group | wc -l
5. Найти строки, содержащие List или System в файле /etc/passwd:
    ```bash
    grep -E 'List|System' /etc/passwd
6. Найти все файлы и директории в /usr, которые заканчиваются на li:
    ```bash
    find /usr -name '*li'
7. Найти только файлы в домашней директории пользователя:
    ```bash
    find ~ -type f
8. Найти только директории в домашней директории пользователя:
    ```bash
    find ~ -type d
9. Найти все файлы, принадлежащие пользователю student:
    ```bash
    find / -user student
10. Найти все файлы, принадлежащие группе ftp:
    ```bash
    find / -group ftp
11. Найти файлы размером больше 200MB:
    ```bash
    find / -type f -size +200M
12. Найти файлы нулевого размера в /tmp:
    ```bash
    find /tmp -type f -size 0
### Файловые системы
1. Просмотреть информацию о дисках и разделах:
    ```bash
    fdisk -l
2. Узнать, какие из дисков имеют разметку:
    ```bash
    lsblk
3. Проверить свободное место на разделах:
    ```bash
    df -h
4. Добавить новый жесткий диск размером 1 ГБ в виртуальную машину. После перезагрузки проверить его наличие:
    ```bash
    ls /dev/ | grep sd
5. Создать два раздела на новом диске (размером по 256 МБ):
    ```bash
    fdisk /dev/sdb
    Команда (m для справки): n
    Тип раздела
    p   основной (0 primary, 0 extended, 4 free)
    e   расширенный (контейнер для логических разделов)
    Выберите (по умолчанию - p):

    Используется ответ по умолчанию p
    Номер раздела (1-4, default 1): 
    Первый сектор (2048-2097151, default 2048): 
    Last sector, +/-sectors or +/-size{K,M,G,T,P} (2048-2097151, default 2097151): +256M
6. Создать файловые системы ext3 и ext4 на разделах:
    ```bash
    mkfs.ext3 /dev/sdb1
    mkfs.ext4 /dev/sdb2
7. Создать директорию для монтирования первого раздела:
    ```bash
    mkdir -p /mnt/data
8. Примонтировать раздел в /mnt/data:
    ```bash
    mount /dev/sdX1 /mnt/data
9. Размонтировать директорию:
    ```bash
    umount /mnt/data
10. Отредактировать файл /etc/fstab для автоматического монтирования второго раздела при загрузке:
    Для того, чтобы узнать UUID раздела использовать команду `blkid /dev/sdb1`

    ```bash
    nano /etc/fstab
    UUID=c079312c-b6e8-4967-802c-c260cde7892f       /mnt/data       ext3    defaul    0   2 
### Управление пользователями

1. Создайте пользователя student1 без домашнего каталога, с пользовательской оболочкой 
/bin/sh и с UID = 777:
    ```bash
     useradd -M -s /bin/sh -u 777 student1
2. Создайте пользователя student2 с истекающим сроком учетной записи 1 июня 2024 года 
и с указанием дополнительной информации «Временный аккаунт». Проверьте 
установленные параметры с помощью следующих команд: chage -l student2 grep -E ‘student2’ /etc/passwd
    ```bash
     useradd -e 2024-06-01 -c "Временный аккаунт" student2
    chage -l student2
    grep -E 'student2' /etc/passwd
3. Создайте пользователя student3 и задайте ему пароль. Двумя разными способами 
запретите пользователю student3 входить в систему.
    ```bash
     useradd student3
     passwd student3
     usermod -L student3
     usermod -s /sbin/nologin student3
4. Создайте пользователя student4 и задайте ему пароль. С помощью команды chage для 
данного пользователя установите минимальный срок действия пароля на 7 дней, 
максимальный срок действия пароля – на 90 дней, предупреждение о сроке действия 
пароля за 10 дней до истечения. Проверьте установленные параметры с помощью 
следующей команды:  chage -l student4.
    ```bash
     useradd student4
     passwd student4
     chage -m 7 -M 90 -W 10 student4
5. Создайте пользователя student5 и задайте ему пароль. Создайте группу course и добавьте 
в нее пользователей student4 и student5.
    ```bash
     groupadd course
     usermod -aG course student4
     usermod -aG course student5
6. Войдите в систему под пользователем student4. Попробуйте перейти в директорию 
пользователя student5 и создать файл file1. Измените права доступа так, чтобы данная 
действие стало возможным. 
    ```bash
    su - student4
    cd /home/student5
    touch file1
     chmod o+wx /home/student5
7. Войдите в систему под пользователем student4. Создайте в директории /tmp файл 
forall.txt. Теперь войдите в систему под пользователем student5 и попробуйте удалить файл 
forall.txt в каталоге /tmp. 
    ```bash
    su - student4
    touch /tmp/forall.txt
    su - student5
    rm /tmp/forall.txt
     chmod 777 /tmp/forall.txt
8. Войдите в систему под пользователем student5. Создайте в домашней директории файл 
testfile.txt. Используя команду umask, установите маску доступа к файлам таким образом, 
чтобы только владелец имел права на чтение, запись и исполнение, а остальные 
пользователи не имели никаких прав на доступ к файлу. Для проверки создайте в 
домашней директории файл testfile2.txt. Сравните права доступа файлов testuser.txt и 
testuser2.txt. 
    ```bash
    su - student5
    umask 077
    touch ~/testfile.txt
    touch ~/testfile2.txt
    ls -l ~/testfile.txt ~/testfile2.txt
9. Войдите в систему под пользователем student5. Создайте файл important.doc и 
установите доступ к нему таким образом, чтобы пользователь student1 имел права на 
чтение и запись, пользователь student2 имел право только на чтение, а остальные 
пользователи не имели никаких прав на доступ к файлу
    ```bash
    su - student5
    touch ~/important.doc
     setfacl -m u:student1:rw ~/important.doc
     setfacl -m u:student2:r ~/important.doc
     chmod 600 ~/important.doc
### Управление конфигурациями
1. Сколько различных shell-оболочек используется пользователями в вашей 
системе? Перечислите их. 
    ```bash
    cat /etc/passwd | awk -F: '{print $7}' | sort | uniq
2. Выведите переменные окружения командой printenv. 
    ```bash
    printenv
3. Введите команду вида: export MY_VARIABLE="значение", где 
MY_VARIABLE – имя вашей переменной, а "значение" – значение, которое 
вы хотите присвоить.
    ```bash
    export MY_VARIABLE="мое значение"
4. Введите echo $MY_VARIABLE в терминале.
    ```bash
    [root@host-133 ~]# echo $MY_VARIABLE
    мое значение
5. Изучите файлы /etc/profile, /etc/bashrc и /etc/environment. 
Внесите изменения в эти файлы, чтобы настроить общесистемные 
переменные окружения, пути поиска и другие параметры: 
В файле /etc/profile: 
export MY_VAR="value" 
В файле /etc/bashrc: 
export PATH=$PATH:/new/path 
В файле /etc/environment: 
MY_VAR="value" 
Проверьте, как изменения влияют на всех пользователей системы: 
Введите команду echo $MY_VAR 
Введите команду echo $PATH 
    ```bash
    В /etc/profile добавьте строку для задания переменной окружения:
    export MY_VAR="value"
    В /etc/bashrc добавьте новый путь к переменной PATH:
    export PATH=$PATH:/new/path
    В /etc/environment добавьте строку для задания значения переменной (без export):
    MY_VAR="value"
6. Создайте любой псевдоним (alias) и добавьте этот псевдоним в файл 
/etc/bashrc.  
Перезапустите оболочку: 
source /etc/bashrc 
Проверьте работу псевдонима. 
    ```bash
    alias ll='ls -la'
    Для перезагрузки настроек выполните:
    source /etc/bashrc
### Процессы
1. Запустите процесс sleep 1000 в фоновом режиме. Переместите его на 
передний план. Остановите процесс с помощью сочетания клавиш Ctrl+Z. 
Запустите его в фоновом режиме и завершите с помощью команды kill.
    ```bash
    sleep 1000 &
    fg %<номер_процесса>(номер можно посмотреть с помощью jobs)
2. На ВМ откройте рядом два окна терминала. Далее эти два терминала будут 
называться левым и правым. Создайте новый каталог с именем /home/student/bin. 
В новом каталоге создайте сценарий оболочки с именем control. Сделайте сценарий 
исполняемым. 
    ```bash
    $ vim /home/student/bin/control  
    #!/bin/bash 
    while true; do 
    echo -n “$@” >> /home/student/bin/control_outfile  
    sleep 1 
    done 
    $ chmod +x /bin/control
    ```
    ```bash
    [root@host-133 ~]# mkdir -p /home/student/bin
    [root@host-133 ~]# vim /home/student/bin/control(вставить необходимый код и выйти :wq)
    [root@host-133 ~]# chmod +x /home/student/bin/control
3. В командной оболочке левого терминала просмотрите список jobs. Помните, 
что знак + указывает на задание по умолчанию. Перезапустите задание в фоновом 
режиме: 
$ sh control first 
В командной оболочке правого терминала убедитесь, что вывод данных процесса 
снова активен. 
    ```bash
    /home/student/bin/control first &
    tail -f /home/student/bin/control_outfile
4. В командной оболочке левого терминала запустите еще два процесса control 
для добавления вывода в файл ~/control_outfile. Используйте амперсанд (&), чтобы 
запустить процессы в фоновом режиме. Замените first на second, а затем на third. 
Замена аргументов помогает различить эти три процесса. 
    ```bash
    /home/student/bin/control second &
    /home/student/bin/control third &
5. Приостановите процесс control first. Убедитесь, что он был приостановлен. 
Завершите процесс control second и убедитесь, что он прекращен.
    ```bash
    команда kill
### Bash скрипты
1. Создайте и выполните простой сценарий Bash.

    1.1. Создайте новый текстовый файл в домашнем каталоге и назовите его `firstscript.sh`.

        touch ~/firstscript.sh
    1.2. Отредактируйте файл `firstscript.sh`, добавив следующий текст:

        #!/bin/bash
        echo "This is my first bash script" > ~/output.txt
        echo "" >> ~/output.txt
        echo "#####################################################" >> ~/output.txt

        > Обратите внимание, что количество символов решетки (`#`) произвольное.
    1.3. Сделайте файл `firstscript.sh` исполняемым с помощью команды `chmod`.

        chmod +x ~/firstscript.sh

    1.4. Выполните команду `sh`, чтобы запустить сценарий:

        sh ~/firstscript.sh

    1.5. Просмотрите выходной файл, сформированный сценарием:

        cat ~/output.txt

2. Добавьте в сценарий `firstscript.sh` дополнительные команды, выполните его и изучите вывод.
   
    2.1. Отредактируйте файл `firstscript.sh`, добавив следующие команды:

        #!/bin/bash
        #
        echo "This is my first bash script" > ~/output.txt
        echo "" >> ~/output.txt
        echo "#####################################################" >> ~/output.txt
        echo "LIST BLOCK DEVICES" >> ~/output.txt
        echo "" >> ~/output.txt
        lsblk >> ~/output.txt
        echo "" >> ~/output.txt
        echo "#####################################################" >> ~/output.txt
        echo "FILESYSTEM FREE SPACE STATUS" >> ~/output.txt
        echo "" >> ~/output.txt
        df -h >> ~/output.txt
        echo "#####################################################" >> ~/output.txt

    2.2. Запустите сценарий `firstscript.sh`:

        sh ~/firstscript.sh

    2.3. Просмотрите выходной файл, сформированный сценарием:

        cat ~/output.txt
3.  Напишите скрипт, который принимает на вход имя файла или директории и выводит 
информацию о том, существует ли указанный файл или директория, является ли это 
файлом или директорией, а также имеет ли текущий пользователь права на чтение, запись 
и выполнение этого файла или директории. 
    ```bash
    #!/bin/bash

    if [ -e "$1" ]; then
        if [ -f "$1" ]; then
            echo "$1 - это файл."
        elif [ -d "$1" ]; then
            echo "$1 - это директория."
        fi

        [[ -r "$1" ]] && echo "Имеется право на чтение."
        [[ -w "$1" ]] && echo "Имеется право на запись."
        [[ -x "$1" ]] && echo "Имеется право на выполнение."
    else
        echo "$1 не существует."
    fi
4. Напишите скрипт, который проверяет, достаточно ли свободного места на диске для 
создания файла заданного размера. Скрипт должен принимать на вход путь к директории 
и размер файла в мегабайтах. Если места недостаточно, скрипт должен выводить 
сообщение об ошибке. 
    ```bash
    #!/bin/bash

    dir="$1"
    size_mb="$2"

    available_space=$(df --output=avail -m "$dir" | tail -n 1)

    if (( available_space >= size_mb )); then
        echo "Достаточно места для файла размером ${size_mb}MB."
    else
        echo "Недостаточно места для файла размером ${size_mb}MB."
    fi
5. Напишите скрипт, который проверяет, подключен ли указанный пользователь к 
системе. Если пользователь подключен, скрипт должен вывести сообщение с именем 
пользователя и временем его подключения. Если пользователь не подключен, вывести 
соответствующее сообщение. 
    ```bash
    #!/bin/bash

    if who | grep -qw "$1"; then
        echo "Пользователь $1 подключен."
        who | grep -w "$1"
    else
        echo "Пользователь $1 не подключен."
    fi
6. Напишите скрипт, который архивирует все файлы в заданной директории в архив с 
именем, соответствующим текущей дате. Скрипт должен принимать на вход путь к 
директории и проверять, существует ли эта директория и имеет ли текущий пользователь 
права на чтение этой директории. Если директория не существует или прав недостаточно, 
вывести сообщение об ошибке. 
    ```bash
    #!/bin/bash

    dir="$1"
    archive_name="$(date +%Y-%m-%d).tar.gz"

    if [ -d "$dir" ] && [ -r "$dir" ]; then
        tar -czf "$archive_name" -C "$dir" .
        echo "Файлы архивированы в $archive_name"
    else
        echo "Ошибка: директория не существует или нет прав на чтение."
    fi
7. Напишите скрипт, который создает резервные копии всех файлов в указанной 
директории, добавляя к их именам суффикс ".bak". Скрипт должен использовать цикл for 
для перебора файлов в директории. 
    ```bash
    #!/bin/bash

    dir="$1"

    for file in "$dir"/*; do
        if [ -f "$file" ]; then
            cp "$file" "${file}.bak"
            echo "Создана резервная копия для $file"
        fi
    done
8. Напишите скрипт, который каждые 5 секунд проверяет использование CPU и памяти 
системой и выводит эту информацию на экран. Скрипт должен использовать бесконечный 
цикл while для выполнения проверки и команду sleep для ожидания. 
    ```bash
    #!/bin/bash

    while true; do
        echo "CPU и память:"
        top -b -n 1 | grep -E "Cpu|Mem"
        sleep 5
    done
9. Напишите скрипт, которые выполняет следующие действия: 
- Проверяет статус указанных служб (например, sshd); 
- Если служба не запущена, то скрипт пытается запустить её; 
- Логирует все действия (проверка, запуск), в том числе ошибки запуска службы,  
в лог-файл с указанием времени выполнения.
    ```bash
    #!/bin/bash

    # Проверка, заданы ли аргументы
    if [ $# -lt 1 ]; then 
        echo "Параметры не заданы" 
        exit 1 
    fi 

    # Имена служб из аргументов
    services=$@ 
    log_file="/var/log/service_manager.log" 

    # Функция для логирования
    log() { 
        local message=$1 
        current_date=$(date +"%Y-%m-%d %H:%M:%S")  # Обновляем дату каждый раз при записи
        echo "$current_date: $message" >> "$log_file" 
    } 

    # Функция для проверки и запуска служб
    check_and_start_service() { 
        local service=$1 
        if systemctl is-active --quiet "$service"; then 
            log "Служба $service уже запущена." 
            echo "Служба $service уже запущена." 
        else 
            log "Служба $service не запущена. Попытка запуска..." 
            echo "Служба $service не запущена. Попытка запуска..." 
            # Перенаправление stderr в /dev/null 
            systemctl start "$service" 2>/dev/null 
            if systemctl is-active --quiet "$service"; then 
                log "Служба $service успешно запущена." 
                echo "Служба $service успешно запущена." 
            else 
                log "Не удалось запустить службу $service." 
                echo "Не удалось запустить службу $service." 
            fi 
        fi 
    } 

    # Проверка и запуск всех указанных служб
    for service in $services; do 
        check_and_start_service "$service" 
    done 

    # Окончательное сообщение с указанием пути к лог-файлу
    echo "Проверка и управление службами завершены. Логи записаны в $log_file."