# Git Cheatsheet

## Содержание

1. [Навигация по файловой системе](#навигация-по-файловой-системе)
2. [Работа с файлами и папками](#работа-с-файлами-и-папками)
   - [Создание](#создание)
   - [Копирование и перемещение](#копирование-и-перемещение)
   - [Чтение](#чтение)
   - [Удаление](#удаление)
3. [Git](#git)
   - [Основные команды](#основные-команды)
   - [Работа с удаленным репозиторием](#работа-с-удаленным-репозиторием)
   - [Слияние и управление коммитами](#слияние-и-управление-коммитами)
   - [Работа с ветками](#работа-с-ветками)
   - [Решение конфликтов](#решение-конфликтов)
   - [Команда git reset](#команда-git-reset)
   - [Команда git revert](#команда-git-revert)
   - [Git rebase](#git-rebase)
   - [Дополнительные команды](#дополнительные-команды)


## Навигация по файловой системе

- **`pwd`**: Показывает текущую рабочую директорию.
- **`ls`**: Показывает содержимое текущей директории.
- **`ls -a`**: Показывает скрытые файлы и папки.
- **`cd <directory>`**: Переходит в указанную директорию.
- **`cd ..`**: Переходит на уровень выше.
- **`cd ~`**: Переходит в домашнюю директорию.
- **`cd /`**: Переходит в корневую директорию.

## Работа с файлами и папками

### Создание

- **`touch <filename>`**: Создает файл(ы).
- **`mkdir <directory>`**: Создает новую папку.

### Копирование и перемещение

- **`cp <source> <destination>`**: Копирует файл(ы) или папку(и).
- **`mv <source> <destination>`**: Перемещает файл(ы) или папку(и).

### Чтение

- **`cat <filename>`**: Выводит содержимое файла.

### Удаление

- **`rm <filename>`**: Удаляет файл(ы).
- **`rmdir <directory>`**: Удаляет папку(и).
- **`rm -r <directory>`**: Удаляет папку(и) и их содержимое рекурсивно.

## Git

### Основные команды

- **`git init`**: Инициализирует Git репозиторий.
- **`rm -rf .git`**: Удаляет Git репозиторий.
- **`git status`**: Показывает состояние репозитория.
- **`git add <files>`**: Добавляет файлы для отслеживания.
- **`git commit -m "<message>"`**: Создает коммит с указанным сообщением.
- **`git log`**: Показывает историю коммитов.

### Работа с удаленным репозиторием

- **`git remote add <name> <url>`**: Связывает локальный репозиторий с удаленным.
- **`git remote -v`**: Показывает связанные удаленные репозитории.
- **`git fetch <remote>`**: Получает последние изменения из удаленного репозитория без их объединения.
  - **Пример использования**:
    ```sh
    git fetch origin
    ```
    Эта команда скачивает все изменения из удаленного репозитория `origin`, не изменяя при этом рабочую директорию или индекс.
- **`git remote update`**: Обновляет все удаленные ветки, скачивая изменения без выполнения слияния.
  - **Пример использования**:
    ```sh
    git remote update
    ```
    Эта команда полезна, когда нужно получить последние изменения для всех удаленных репозиториев.

### Слияние и управление коммитами

- **`git merge <branch_name>`**: Выполняет слияние указанной ветки с текущей.
  - **Пример использования**:
    ```sh
    git merge feature-branch
    ```
    Эта команда объединит ветку `feature-branch` с текущей веткой, на которой вы находитесь.
- **`git cherry-pick <commit>`**: Применяет указанный коммит к текущей ветке.
  - **Пример использования**:
    ```sh
    git cherry-pick 8fe1498
    ```
    Этот пример применяет коммит с хешем `8fe1498` в текущую ветку.
  - Выборка нескольких коммитов:
    ```sh
    git cherry-pick 8fe1498 mega_fix~3 v1.0.1
    ```
    В этом случае, команда применит коммит с хешем `8fe1498`, третий коммит до `mega_fix`, и коммит с меткой `v1.0.1` к текущей ветке.

### Работа с ветками

- **`git branch <branch_name>`**: Создает новую ветку с указанным именем.
  - **Пример использования**:
    ```sh
    git branch bugFix
    ```
    Эта команда создает новую ветку с именем `bugFix`.
- **`git checkout -b <branch_name>`**: Создает и переключается на новую ветку.
  - **Пример использования**:
    ```sh
    git checkout -b feature-branch
    ```
    Эта команда создаст ветку `feature-branch` и сразу переключится на нее.
- **`git branch -m <new_name>`**: Переименовывает текущую ветку.
  - **Пример использования**:
    ```sh
    git branch -m new-feature-branch
    ```
    Эта команда переименовывает текущую ветку в `new-feature-branch`.

### Решение конфликтов

Конфликты в Git возникают, когда два разных коммита изменяют одну и ту же строку файла или когда один разработчик изменяет файл, который был удален другим разработчиком. Git отмечает такие конфликты в файлах и требует вмешательства пользователя для их разрешения.

- **Обнаружение конфликта**: После выполнения `git merge` или `git rebase`, если есть конфликты, Git предупредит об этом и отметит конфликтные файлы.
- **Пример разрешения конфликта**:
  1. Откройте файл с конфликтом, который будет содержать конфликтные секции, выделенные следующими маркерами:
     ```sh
     <<<<<<< HEAD
     содержимое вашей текущей ветки
     =======
     содержимое ветки, которую вы сливаете
     >>>>>>> ветка-имя
     ```
  2. Разрешите конфликт, выбрав нужную версию изменений или объединив их.
  3. После разрешения конфликта выполните `git add` для конфликтного файла.
  4. Завершите процесс слияния или перебазирования с помощью `git commit` (в случае слияния) или `git rebase --continue` (в случае rebase).
  
- **Пример:**
  ```sh
  git merge feature-branch
  # Конфликт в файле example.txt
  # Открываем файл и редактируем его:
  <<<<<<< HEAD
  Строка из вашей ветки.
  =======
  Строка из feature-branch.
  >>>>>>> feature-branch
  
  # Выбираем нужный вариант или объединяем изменения, затем сохраняем файл:
  git add example.txt
  git commit -m "Решение конфликта в example.txt"
### Команда git reset

- **`git reset HEAD~`**: Удаляет последний коммит, оставляя изменения в рабочей директории.
  - **Пример использования**:
    ```sh
    git reset HEAD~
    ```
    Эта команда удаляет последний коммит, но сохраняет все изменения в файлах, чтобы их можно было закоммитить снова.

- **`git reset --hard HEAD~`**: Удаляет последний коммит вместе с изменениями.
  - **Пример использования**:
    ```sh
    git reset --hard HEAD~
    ```
    В этом случае коммит и изменения будут полностью удалены, как будто они никогда не существовали.

- **`git reset --soft <commit>`**: Перемещает указатель HEAD на указанный коммит, оставляя изменения в индексе.
  - **Пример использования**:
    ```sh
    git reset --soft HEAD~2
    ```
    Эта команда вернет текущую ветку на два коммита назад, сохранив изменения для дальнейшего коммита.

### Команда git revert

- **`git revert <commit_hash>`**: Создает новый коммит, который отменяет изменения указанного коммита.
  - **Пример использования**:
    ```sh
    git revert aa600a43cb164408e4ad87d216bc679d097f1a6c
    ```
    Этот пример создает новый коммит, который отменяет изменения, внесенные коммитом `aa600a43cb164408e4ad87d216bc679d097f1a6c`.

### Git rebase

- **`git rebase --onto <new_base> <old_base> <branch>`**: Перебазирует коммиты с `old_base` на `new_base`.
  - **Пример использования**:
    ```sh
    git rebase --onto main~3 feature-branch
    ```
    Эта команда перенесет коммиты из `feature-branch`, начиная с `main~3`, на новую базу.

### Дополнительные команды

- **`git stash`**: Сохраняет текущие изменения в рабочей директории для их применения позже.
  - **Пример использования**:
    ```sh
    git stash
    ```
    Эта команда позволяет временно сохранить изменения в рабочей директории, чтобы переключиться на другую ветку без необходимости делать коммит.

- **`git add .`**: Переносит все изменения из рабочего каталога в раздел проиндексированных файлов.
  - **Пример использования**:
    ```sh
    git add .
    ```
    Эта команда добавляет все изменения в индексацию для последующего коммита.
